-- luapacked using 0.4.3
local e=arg package.preload["__luapack_entry__"]=function(...)local t=e local a={}local o=[[require%s*%(?%s*(["'])(.-)%1]]local i=select(2,pcall(function()return require("lib/minifier")end))local n=select(2,pcall(require,"yue"))local s=select(2,pcall(require,"moonscript.base"))local h h=function(j,x)j[j.n+1]=x j.n=j.n+1 end local r do local j local x={indent=function(z)return("\t"):rep(z.dept)end,writeln=function(z,_)return h(z.out,tostring(z:indent())..tostring(_))end,writelines=function(z,_)for E in _:gmatch("[^\n]+")do z:writeln(E)end end,incr=function(z)z.dept=z.dept+1 end,decr=function(z)z.dept=z.dept-1 end,wrap=function(z,_)z:incr()_()return z:decr()end,endwrap=function(z,_)z:wrap(_)return z:writeln("end")end,str=function(z)return table.concat(z.out,"\n")end}if x.__index==nil then x.__index=x end j=setmetatable({__init=function(z)z.dept=0 z.out={n=0}end,__base=x,__name="Writer"},{__index=x,__call=function(z,...)local _=setmetatable({},x)z.__init(_,...)return _ end})x.__class=j r=j end local d d=function(j,x)if package.searchpath then package.searchpath(j,x)end local z=";"j=j:gsub("%.","/")for x in x:gmatch("[^;]+")do x=x:gsub("?",j)local _=io.open(x,"r")if(_~=nil)then _:close()return x end end end local l l=function(j)return package.path:gsub("%.lua","."..tostring(j))end local u u=function(j,x)return x==j:sub(-#x)end local c c=function(j,x,z)return j:gsub("%"..tostring(x).."$",z)end local m={fast_push=h,searchpath_compat=d,package_path_with_different_extension=l,check_file_extension=u}a["helpers"]=m local f="Leo Developer"a["__author__"]=f local w="https://github.com/le0developer/luapack"a["__url__"]=w local y="MIT"a["__license__"]=y local p="0.4.3"a["__version__"]=p local v={n=0}a["default_plugins"]=v h(v,{name="lua",searchpath=function(j,x)return d(x,package.path)end})if"table"==type(n)then h(v,{name="yuescript",searchpath=function(j,x)return d(x,l("yue"))end,loader=function(j,x,z,_)if not u(z,".yue")then return false end local E=n.to_lua(_,{reserve_line_number=false})return E,c(z,".yue",".lua")end})end if"table"==type(s)then h(v,{name="moonscript",searchpath=function(j,x)return d(x,l("moon"))end,loader=function(j,x,z,_)if not u(z,".moon")then return false end local E=s.to_lua(_)return E,c(z,".moon",".lua")end})end local b do local j local x={extract_packages=function(z,_)local E={n=0}for T,A in _:gmatch(o)do h(E,A)end return E end,include=function(z,_,E)local T=z.options.plugins or v local A=1 while not(E~=nil)do local I=T[A]if not(I~=nil)then return end if(I.searchpath~=nil)then E=I.searchpath(z,_)if(E~=nil)then break end end A=A+1 end if(z.loaded[_]~=nil)then return end do local I=io.open(E,"r")if not(I~=nil)then error("file not found: "..tostring(E))end z.loaded[_]=I:read("*a")I:close()end for I=1,#T do local N=T[I]local S=false repeat if not(N.loader~=nil)then S=true break end local H,R=N.loader(z,_,E,z.loaded[_])if H then z.loaded[_]=H end if R then E=E end S=true until true if not S then break end end if"-- luapacked"==z.loaded[_]:sub(1,12)then return end local O=z:extract_packages(z.loaded[_])for I=1,#O do local N=O[I]z:include(N)end end,pack=function(z,_)z:include("__luapack_entry__",_)if not(z.loaded["__luapack_entry__"]~=nil)then error("file not found: "..tostring(_))end if z.options.include_entry==false then z.loaded["__luapack_entry__"]=nil end end,export=function(z)local _=z:bootstrap()if z.options.minify~=false and"table"==type(i)then _=i.Rebuild.MinifyString(_)end local E=""if z.options.with_header~=false then E="-- luapacked using "..tostring(p).."\n"end return E.._ end,bootstrap=function(z)local _=r()if z.options.compat_arg~=false then for T,A in pairs(z.loaded)do if A:match("%.%.%.")then _:writeln("local __luapack_arg__ = arg")break end end end if z.options.package_polyfill then _:writeln("if not package then _G.package = {preload = {}, loaded = {}} end")_:writeln("if not package.preload then package.preload = {} end")_:writeln("if not package.loaded then package.loaded = {} end")_:writeln("if not require then")_:endwrap(function()_:writeln("local sentinel = {}")_:writeln("_G.require = function(modname)")return _:endwrap(function()_:writeln("if package.loaded[modname] == sentinel then")_:endwrap(function()return _:writeln('error(("loop or previous error loading module %q"):format(modname), 0)')end)_:writeln("if package.loaded[modname] ~= nil then return package.loaded[name] end")_:writeln("if not package.preload[modname] then")_:endwrap(function()return _:writeln('error(("module not found %q"):format(modname), 2)')end)_:writeln("package.loaded[modname] = sentinel")_:writeln('local success, result = pcall(package.preload[modname], modname, ":preload:")')_:writeln("if not success then")_:endwrap(function()_:writeln("package.loaded[modname] = nil")return _:writeln("error(result)")end)_:writeln("if result == nil then result = true end")_:writeln("package.loaded[modname] = result")return _:writeln('return result, ":preload:"')end)end)end local E={}for T,A in pairs(z.loaded)do if E[A]then _:writeln(("package.preload[%q] = package.preload[%q]"):format(T,E[A]))else _:writeln(("package.preload[%q] = function(...)"):format(T))_:endwrap(function()if z.options.compat_arg~=false and A:match("%.%.%.")then _:writeln("local arg = __luapack_arg__")end return _:writelines(A)end)E[A]=T end if z.options.clear_loaded~=false then _:writeln(("package.loaded[%q] = nil"):format(T))end end if(z.loaded["__luapack_entry__"]~=nil)then _:writeln("do")_:endwrap(function()_:writeln('local _result = package.preload["__luapack_entry__"](...)')return _:writeln("return _result")end)end return _:str()end}if x.__index==nil then x.__index=x end j=setmetatable({__init=function(z,_)if _==nil then _={}end z.options=_ z.loaded={}end,__base=x,__name="Packer"},{__index=x,__call=function(z,...)local _=setmetatable({},x)z.__init(_,...)return _ end})x.__class=j b=j end a["Packer"]=b local g g=function(j)local x={}for _=1,#j do local t=j[_]local E=false repeat if"-"~=t:sub(1,1)then E=true break end local T,A=t:match("^-(%w+)-([%w-]+)$")if T~="yes"and T~="no"then E=true break end A=A:gsub("-","_")x[A]=T=="yes"E=true until true if not E then break end end print("Using luapack "..tostring(p))local z=table.concat((function()local _={}local E=1 for T,A in pairs(x)do _[E]=tostring(T).."="..tostring((function()if A then return"yes"else return"no"end end)())E=E+1 end return _ end)(),", ")if#z>0 then print("Options: "..tostring(z))end print()for _=1,#j do local E=j[_]local T=false repeat if"-"==E:sub(1,1)then T=true break end print("Packing "..tostring(E))local A=b(x)if x.standalone then local N do local S=io.open(E,"r")N=S:read("*a")S:close()end for S in N:gmatch("[^\n]+")do A:include(S)end else A:pack(E)end local O=A:export()local I=E:gsub("%.(%a+)$",function(N)return".packed.lua"end)print("Packed into "..tostring(I))if E==I then break end do local N=io.open(I,"w")N:write(O)N:close()end T=true until true if not T then break end end end local k k=function(j)if j.n==0 then return end if j[2]==":preload:"then return end if not(t~=nil)then return end for x=1,j.n do if t[x]~=j[x]then return end end return true end local q={...}q.n=#q if k(q)then g(q)end return a end package.loaded["__luapack_entry__"]=nil package.preload["lib/minifier"]=function(...)local t=e local a if not getfenv then function a(o)local i=false return setmetatable({},{__index=function(n,s)if not i then i=o()end return i[s]end,__call=function(n,...)if not i then i=o()end return i(...)end})end else function a(o)local i=setmetatable({},{__index=getfenv()})return setfenv(o,i)()or i end end Utils=a(function()return{CreateLookup=function(o)for i,n in ipairs(o)do o[n]=true end return o end}end)Constants=a(function()createLookup=Utils.CreateLookup WhiteChars=createLookup{' ','\n','\t','\r'}EscapeLookup={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'"}LowerChars=createLookup{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}UpperChars=createLookup{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}Digits=createLookup{'0','1','2','3','4','5','6','7','8','9'}HexDigits=createLookup{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}Symbols=createLookup{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}Keywords=createLookup{'and','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'}StatListCloseKeywords=createLookup{'end','else','elseif','until'}UnOps=createLookup{'-','not','#'}return{WhiteChars=WhiteChars,EscapeLookup=EscapeLookup,LowerChars=LowerChars,UpperChars=UpperChars,Digits=Digits,HexDigits=HexDigits,Symbols=Symbols,Keywords=Keywords,StatListCloseKeywords=StatListCloseKeywords,UnOps=UnOps}end)Scope=a(function()local o=Constants.Keywords local i={}function i:AddLocal(s)table.insert(self.Locals,s)end function i:CreateLocal(s)local h=self:GetLocal(s)if h then return h end h={Scope=self,Name=s,IsGlobal=false,CanRename=true,References=1}self:AddLocal(h)return h end function i:GetLocal(s)for h,r in pairs(self.Locals)do if r.Name==s then return r end end if self.Parent then return self.Parent:GetLocal(s)end end function i:GetOldLocal(s)if self.oldLocalNamesMap[s]then return self.oldLocalNamesMap[s]end return self:GetLocal(s)end function i:RenameLocal(s,h)s=type(s)=='string'and s or s.Name local r=false local d=self:GetLocal(s)if d then d.Name=h self.oldLocalNamesMap[s]=d r=true end if not r and self.Parent then self.Parent:RenameLocal(s,h)end end function i:AddGlobal(s)table.insert(self.Globals,s)end function i:CreateGlobal(s)local h=self:GetGlobal(s)if h then return h end h={Scope=self,Name=s,IsGlobal=true,CanRename=true,References=1}self:AddGlobal(h)return h end function i:GetGlobal(s)for h,r in pairs(self.Globals)do if r.Name==s then return r end end if self.Parent then return self.Parent:GetGlobal(s)end end function i:GetOldGlobal(s)if self.oldGlobalNamesMap[s]then return self.oldGlobalNamesMap[s]end return self:GetGlobal(s)end function i:RenameGlobal(s,h)s=type(s)=='string'and s or s.Name local r=false local d=self:GetGlobal(s)if d then d.Name=h self.oldGlobalNamesMap[s]=d r=true end if not r and self.Parent then self.Parent:RenameGlobal(s,h)end end function i:GetVariable(s)return self:GetLocal(s)or self:GetGlobal(s)end function i:GetOldVariable(s)return self:GetOldLocal(s)or self:GetOldGlobal(s)end function i:RenameVariable(s,h)s=type(s)=='string'and s or s.Name if self:GetLocal(s)then self:RenameLocal(s,h)else self:RenameGlobal(s,h)end end function i:GetAllVariables()return self:getVars(true,self:getVars(true))end function i:getVars(s,h)local h=h or{}if s then for r,d in pairs(self.Children)do d:getVars(true,h)end else for r,d in pairs(self.Locals)do table.insert(h,d)end for r,d in pairs(self.Globals)do table.insert(h,d)end if self.Parent then self.Parent:getVars(false,h)end end return h end function i:ObfuscateLocals(s)local h=s or"etaoinshrdlucmfwypvbgkqjxz_ETAOINSHRDLUCMFWYPVBGKQJXZ"local r=s or"etaoinshrdlucmfwypvbgkqjxz_0123456789ETAOINSHRDLUCMFWYPVBGKQJXZ"local d,l=#h,#r local u=0 local c=math.floor for m,f in pairs(self.Locals)do local w repeat if u<d then u=u+1 w=h:sub(u,u)else if u<d then u=u+1 w=h:sub(u,u)else local y=c(u/d)local p=u%d w=h:sub(p,p)while y>0 do p=y%l w=r:sub(p,p)..w y=c(y/l)end u=u+1 end end until not(o[w]or self:GetVariable(w))self:RenameLocal(f.Name,w)end end function i:ToString()return'<Scope>'end local function n(s)local h=setmetatable({Parent=s,Locals={},Globals={},oldLocalNamesMap={},oldGlobalNamesMap={},Children={}},{__index=i})if s then table.insert(s.Children,h)end return h end return n end)TokenList=a(function()local o={}function o:Peek(i)local n=self.tokens i=i or 0 return n[math.min(#n,self.pointer+i)]end function o:Get(i)local n=self.tokens local s=self.pointer local h=n[s]self.pointer=math.min(s+1,#n)if i then table.insert(i,h)end return h end function o:Is(i)return self:Peek().Type==i end function o:Save()table.insert(self.savedPointers,self.pointer)end function o:Commit()local i=self.savedPointers i[#i]=nil end function o:Restore()local i=self.savedPointers local n=#i self.pointer=savedP[n]i[n]=nil end function o:ConsumeSymbol(i,n)local s=self:Peek()if s.Type=='Symbol'then if i then if s.Data==i then self:Get(n)return true else return nil end else self:Get(n)return s end else return nil end end function o:ConsumeKeyword(i,n)local s=self:Peek()if s.Type=='Keyword'and s.Data==i then self:Get(n)return true else return nil end end function o:IsKeyword(i)local n=self:Peek()return n.Type=='Keyword'and n.Data==i end function o:IsSymbol(i)local n=self:Peek()return n.Type=='Symbol'and n.Data==i end function o:IsEof()return self:Peek().Type=='Eof'end function o:Print(i)i=(i==nil and true or i)local n=""for s,h in ipairs(self.tokens)do if i then for s,r in ipairs(h.LeadingWhite)do n=n..r:Print().."\n"end end n=n..h:Print().."\n"end return n end return o end)Parse=a(function()local o=Utils.CreateLookup local i=Constants.LowerChars local n=Constants.UpperChars local s=Constants.Digits local h=Constants.Symbols local r=Constants.HexDigits local d=Constants.Keywords local l=Constants.StatListCloseKeywords local u=Constants.UnOps local c=setmetatable local m={}function m:Print()return"<".. (self.Type..string.rep(' ',math.max(3,12-#self.Type))).."  ".. (self.Data or'').." >"end local f={__index=m}local function w(p)local v={}do local g=1 local k=1 local q=1 local function j()local T=p:sub(g,g)if T=='\n'then q=1 k=k+1 else q=q+1 end g=g+1 return T end local function x(T)T=T or 0 return p:sub(g+T,g+T)end local function z(T)local A=x()for O=1,#T do if A==T:sub(O,O)then return j()end end end local function _(T)error(">> :"..k..":"..q..": "..T,0)end local function E()local T=g if x()=='['then local A=0 local O=1 while x(A+1)=='='do A=A+1 end if x(A+1)=='['then for H=0,A+1 do j()end local I=g while true do if x()==''then _("Expected `]"..string.rep('=',A).."]` near <eof>.",3)end local H=true if x()==']'then for R=1,A do if x(R)~='='then H=false end end if x(A+1)~=']'then H=false end else if x()=='['then local R=true for D=1,A do if x(D)~='='then R=false break end end if x(A+1)=='['and R then O=O+1 for D=1,(A+2)do j()end end end H=false end if H then O=O-1 if O==0 then break else for R=1,A+2 do j()end end else j()end end local N=p:sub(I,g-1)for H=0,A+1 do j()end local S=p:sub(T,g-1)return N,S else return nil end else return nil end end while true do local T={}local A=''local O=false while true do local D=x()if D=='#'and x(1)=='!'and k==1 then j()j()A="#!"while x()~='\n'and x()~=''do A=A..j()end table.insert(T,c({Type='Comment',CommentType='Shebang',Data=A,Line=k,Char=q},f))A=""end if D==' 'or D=='\t'then local L=j()table.insert(T,c({Type='Whitespace',Line=k,Char=q,Data=L},f))elseif D=='\n'or D=='\r'then local L=j()if A~=""then table.insert(T,c({Type='Comment',CommentType=O and'LongComment'or'Comment',Data=A,Line=k,Char=q},f))A=""end table.insert(T,c({Type='Whitespace',Line=k,Char=q,Data=L},f))elseif D=='-'and x(1)=='-'then j()j()A=A..'--'local L,U=E()if U then A=A..U O=true else while x()~='\n'and x()~=''do A=A..j()end end else break end end if A~=""then table.insert(T,c({Type='Comment',CommentType=O and'LongComment'or'Comment',Data=A,Line=k,Char=q},f))end local I=k local N=q local S=":"..k..":"..q..":> "local H=x()local R=nil if H==''then R={Type='Eof'}elseif n[H]or i[H]or H=='_'then local D=g repeat j()H=x()until not(n[H]or i[H]or s[H]or H=='_')local L=p:sub(D,g-1)if d[L]then R={Type='Keyword',Data=L}else R={Type='Ident',Data=L}end elseif s[H]or(x()=='.'and s[x(1)])then local D=g if H=='0'and x(1)=='x'then j()j()while r[x()]do j()end if z('Pp')then z('+-')while s[x()]do j()end end else while s[x()]do j()end if z('.')then while s[x()]do j()end end if z('Ee')then z('+-')while s[x()]do j()end end end R={Type='Number',Data=p:sub(D,g-1)}elseif H=='\''or H=='\"'then local D=g local L=j()local U=g while true do local H=j()if H=='\\'then j()elseif H==L then break elseif H==''then _("Unfinished string near <eof>")end end local C=p:sub(U,g-2)local M=p:sub(D,g-1)R={Type='String',Data=M,Constant=C}elseif H=='['then local D,L=E()if L then R={Type='String',Data=L,Constant=D}else j()R={Type='Symbol',Data='['}end elseif z('>=<')then if z('=')then R={Type='Symbol',Data=H..'='}else R={Type='Symbol',Data=H}end elseif z('~')then if z('=')then R={Type='Symbol',Data='~='}else _("Unexpected symbol `~` in source.",2)end elseif z('.')then if z('.')then if z('.')then R={Type='Symbol',Data='...'}else R={Type='Symbol',Data='..'}end else R={Type='Symbol',Data='.'}end elseif z(':')then if z(':')then R={Type='Symbol',Data='::'}else R={Type='Symbol',Data=':'}end elseif h[H]then j()R={Type='Symbol',Data=H}else local D,L=E()if D then R={Type='String',Data=L,Constant=D}else _("Unexpected Symbol `"..H.."` in source.",2)end end R.LeadingWhite=T R.Line=I R.Char=N v[#v+1]=c(R,f)if R.Type=='Eof'then break end end end local b=setmetatable({tokens=v,savedPointers={},pointer=1},{__index=TokenList})return b end local function y(p)local function v(T)local A=">> :"..p:Peek().Line..":"..p:Peek().Char..": "..T.."\n"local O=0 if type(src)=='string'then for I in src:gmatch("[^\n]*\n?")do if I:sub(-1,-1)=='\n'then I=I:sub(1,-2)end O=O+1 if O==p:Peek().Line then A=A..">> `"..I:gsub('\t','    ').."`\n"for N=1,p:Peek().Char do local S=I:sub(N,N)if S=='\t'then A=A..'    'else A=A..' 'end end A=A.."   ^^^^"break end end end error(A)end local b,g,k,q,j local function x(T,A)local O=Scope(T)if not p:ConsumeSymbol('(',A)then v("`(` expected.")end local I={}local N=false while not p:ConsumeSymbol(')',A)do if p:Is('Ident')then local t=O:CreateLocal(p:Get(A).Data)I[#I+1]=t if not p:ConsumeSymbol(',',A)then if p:ConsumeSymbol(')',A)then break else v("`)` expected.")end end elseif p:ConsumeSymbol('...',A)then N=true if not p:ConsumeSymbol(')',A)then v("`...` must be the last argument of a function.")end break else v("Argument name or `...` expected")end end local S=g(O)if not p:ConsumeKeyword('end',A)then v("`end` expected after function body")end return{AstType='Function',Scope=O,Arguments=I,Body=S,VarArg=N,Tokens=A}end function q(T)local A={}if p:ConsumeSymbol('(',A)then local O=b(T)if not p:ConsumeSymbol(')',A)then v("`)` Expected.")end return{AstType='Parentheses',Inner=O,Tokens=A}elseif p:Is('Ident')then local O=p:Get(A)local I=T:GetLocal(O.Data)if not I then I=T:GetGlobal(O.Data)if not I then I=T:CreateGlobal(O.Data)else I.References=I.References+1 end else I.References=I.References+1 end return{AstType='VarExpr',Name=O.Data,Variable=I,Tokens=A}else v("primary expression expected")end end function j(T,A)local O=q(T)while true do local I={}if p:IsSymbol('.')or p:IsSymbol(':')then local N=p:Get(I).Data if not p:Is('Ident')then v("<Ident> expected.")end local S=p:Get(I)O={AstType='MemberExpr',Base=O,Indexer=N,Ident=S,Tokens=I}elseif not A and p:ConsumeSymbol('[',I)then local N=b(T)if not p:ConsumeSymbol(']',I)then v("`]` expected.")end O={AstType='IndexExpr',Base=O,Index=N,Tokens=I}elseif not A and p:ConsumeSymbol('(',I)then local N={}while not p:ConsumeSymbol(')',I)do N[#N+1]=b(T)if not p:ConsumeSymbol(',',I)then if p:ConsumeSymbol(')',I)then break else v("`)` Expected.")end end end O={AstType='CallExpr',Base=O,Arguments=N,Tokens=I}elseif not A and p:Is('String')then O={AstType='StringCallExpr',Base=O,Arguments={p:Get(I)},Tokens=I}elseif not A and p:IsSymbol('{')then local N=k(T)O={AstType='TableCallExpr',Base=O,Arguments={N},Tokens=I}else break end end return O end function k(T)local A={}if p:Is('Number')then return{AstType='NumberExpr',Value=p:Get(A),Tokens=A}elseif p:Is('String')then return{AstType='StringExpr',Value=p:Get(A),Tokens=A}elseif p:ConsumeKeyword('nil',A)then return{AstType='NilExpr',Tokens=A}elseif p:IsKeyword('false')or p:IsKeyword('true')then return{AstType='BooleanExpr',Value=(p:Get(A).Data=='true'),Tokens=A}elseif p:ConsumeSymbol('...',A)then return{AstType='DotsExpr',Tokens=A}elseif p:ConsumeSymbol('{',A)then local O={}local I={AstType='ConstructorExpr',EntryList=O,Tokens=A}while true do if p:IsSymbol('[',A)then p:Get(A)local N=b(T)if not p:ConsumeSymbol(']',A)then v("`]` Expected")end if not p:ConsumeSymbol('=',A)then v("`=` Expected")end local S=b(T)O[#O+1]={Type='Key',Key=N,Value=S}elseif p:Is('Ident')then local N=p:Peek(1)if N.Type=='Symbol'and N.Data=='='then local S=p:Get(A)if not p:ConsumeSymbol('=',A)then v("`=` Expected")end local H=b(T)O[#O+1]={Type='KeyString',Key=S.Data,Value=H}else local S=b(T)O[#O+1]={Type='Value',Value=S}end elseif p:ConsumeSymbol('}',A)then break else local N=b(T)O[#O+1]={Type='Value',Value=N}end if p:ConsumeSymbol(';',A)or p:ConsumeSymbol(',',A)then elseif p:ConsumeSymbol('}',A)then break else v("`}` or table entry Expected")end end return I elseif p:ConsumeKeyword('function',A)then local O=x(T,A)O.IsLocal=true return O else return j(T)end end local z=8 local _={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}function b(T,A)A=A or 0 local O if u[p:Peek().Data]then local I={}local N=p:Get(I).Data O=b(T,z)local S={AstType='UnopExpr',Rhs=O,Op=N,OperatorPrecedence=z,Tokens=I}O=S else O=k(T)end while true do local I=_[p:Peek().Data]if I and I[1]>A then local N={}local S=p:Get(N).Data local H=b(T,I[2])local R={AstType='BinopExpr',Lhs=O,Op=S,OperatorPrecedence=I[1],Rhs=H,Tokens=N}O=R else break end end return O end local function E(T)local A=nil local O={}if p:ConsumeKeyword('if',O)then local I={}local N={AstType='IfStatement',Clauses=I}repeat local S=b(T)if not p:ConsumeKeyword('then',O)then v("`then` expected.")end local H=g(T)I[#I+1]={Condition=S,Body=H}until not p:ConsumeKeyword('elseif',O)if p:ConsumeKeyword('else',O)then local S=g(T)I[#I+1]={Body=S}end if not p:ConsumeKeyword('end',O)then v("`end` expected.")end N.Tokens=O A=N elseif p:ConsumeKeyword('while',O)then local I=b(T)if not p:ConsumeKeyword('do',O)then return v("`do` expected.")end local N=g(T)if not p:ConsumeKeyword('end',O)then v("`end` expected.")end A={AstType='WhileStatement',Condition=I,Body=N,Tokens=O}elseif p:ConsumeKeyword('do',O)then local I=g(T)if not p:ConsumeKeyword('end',O)then v("`end` expected.")end A={AstType='DoStatement',Body=I,Tokens=O}elseif p:ConsumeKeyword('for',O)then if not p:Is('Ident')then v("<ident> expected.")end local I=p:Get(O)if p:ConsumeSymbol('=',O)then local N=Scope(T)local S=N:CreateLocal(I.Data)local H=b(T)if not p:ConsumeSymbol(',',O)then v("`,` Expected")end local R=b(T)local D if p:ConsumeSymbol(',',O)then D=b(T)end if not p:ConsumeKeyword('do',O)then v("`do` expected")end local L=g(N)if not p:ConsumeKeyword('end',O)then v("`end` expected")end A={AstType='NumericForStatement',Scope=N,Variable=S,Start=H,End=R,Step=D,Body=L,Tokens=O}else local N=Scope(T)local S={N:CreateLocal(I.Data)}while p:ConsumeSymbol(',',O)do if not p:Is('Ident')then v("for variable expected.")end S[#S+1]=N:CreateLocal(p:Get(O).Data)end if not p:ConsumeKeyword('in',O)then v("`in` expected.")end local H={b(T)}while p:ConsumeSymbol(',',O)do H[#H+1]=b(T)end if not p:ConsumeKeyword('do',O)then v("`do` expected.")end local R=g(N)if not p:ConsumeKeyword('end',O)then v("`end` expected.")end A={AstType='GenericForStatement',Scope=N,VariableList=S,Generators=H,Body=R,Tokens=O}end elseif p:ConsumeKeyword('repeat',O)then local I=g(T)if not p:ConsumeKeyword('until',O)then v("`until` expected.")end cond=b(I.Scope)A={AstType='RepeatStatement',Condition=cond,Body=I,Tokens=O}elseif p:ConsumeKeyword('function',O)then if not p:Is('Ident')then v("Function name expected")end local I=j(T,true)local N=x(T,O)N.IsLocal=false N.Name=I A=N elseif p:ConsumeKeyword('local',O)then if p:Is('Ident')then local I={p:Get(O).Data}while p:ConsumeSymbol(',',O)do if not p:Is('Ident')then v("local var name expected")end I[#I+1]=p:Get(O).Data end local N={}if p:ConsumeSymbol('=',O)then repeat N[#N+1]=b(T)until not p:ConsumeSymbol(',',O)end for S,H in pairs(I)do I[S]=T:CreateLocal(H)end A={AstType='LocalStatement',LocalList=I,InitList=N,Tokens=O}elseif p:ConsumeKeyword('function',O)then if not p:Is('Ident')then v("Function name expected")end local I=p:Get(O).Data local N=T:CreateLocal(I)local S=x(T,O)S.Name=N S.IsLocal=true A=S else v("local var or function def expected")end elseif p:ConsumeSymbol('::',O)then if not p:Is('Ident')then v('Label name expected')end local I=p:Get(O).Data if not p:ConsumeSymbol('::',O)then v("`::` expected")end A={AstType='LabelStatement',Label=I,Tokens=O}elseif p:ConsumeKeyword('return',O)then local I={}if not p:IsKeyword('end')then local N,S=pcall(function()return b(T)end)if N then I[1]=S while p:ConsumeSymbol(',',O)do I[#I+1]=b(T)end end end A={AstType='ReturnStatement',Arguments=I,Tokens=O}elseif p:ConsumeKeyword('break',O)then A={AstType='BreakStatement',Tokens=O}elseif p:ConsumeKeyword('goto',O)then if not p:Is('Ident')then v("Label expected")end local I=p:Get(O).Data A={AstType='GotoStatement',Label=I,Tokens=O}else local I=j(T)if p:IsSymbol(',')or p:IsSymbol('=')then if(I.ParenCount or 0)>0 then v("Can not assign to parenthesized expression, is not an lvalue")end local N={I}while p:ConsumeSymbol(',',O)do N[#N+1]=j(T)end if not p:ConsumeSymbol('=',O)then v("`=` Expected.")end local S={b(T)}while p:ConsumeSymbol(',',O)do S[#S+1]=b(T)end A={AstType='AssignmentStatement',Lhs=N,Rhs=S,Tokens=O}elseif I.AstType=='CallExpr'or I.AstType=='TableCallExpr'or I.AstType=='StringCallExpr'then A={AstType='CallStatement',Expression=I,Tokens=O}else v("Assignment Statement Expected")end end if p:IsSymbol(';')then A.Semicolon=p:Get(A.Tokens)end return A end function g(T)local A={}local O={Scope=Scope(T),AstType='Statlist',Body=A,Tokens={}}while not l[p:Peek().Data]and not p:IsEof()do local I=E(O.Scope)A[#A+1]=I end if p:IsEof()then local I={}I.AstType='Eof'I.Tokens={p:Get()}A[#A+1]=I end return O end return g(Scope())end return{LexLua=w,ParseLua=y}end)Rebuild=a(function()local o=Constants.LowerChars local i=Constants.UpperChars local n=Constants.Digits local s=Constants.Symbols local function h(u,c,m)m=m or' 'local f,w=u:sub(-1,-1),c:sub(1,1)if i[f]or o[f]or f=='_'then if not(w=='_'or i[w]or o[w]or n[w])then return u..c else return u..m..c end elseif n[f]then if w=='('then return u..c elseif s[w]then return u..c else return u..m..c end elseif f==''then return u..c else if w=='('then return u..m..c else return u..c end end end local function r(u)local c,m local f=0 local function w(p,v,b)return h(p,v,sep)end m=function(p,v)local v=v or 0 local b=0 local g=false local k=""if p.AstType=='VarExpr'then if p.Variable then k=k..p.Variable.Name else k=k..p.Name end elseif p.AstType=='NumberExpr'then k=k..p.Value.Data elseif p.AstType=='StringExpr'then k=k..p.Value.Data elseif p.AstType=='BooleanExpr'then k=k..tostring(p.Value)elseif p.AstType=='NilExpr'then k=w(k,"nil")elseif p.AstType=='BinopExpr'then b=p.OperatorPrecedence k=w(k,m(p.Lhs,b))k=w(k,p.Op)k=w(k,m(p.Rhs))if p.Op=='^'or p.Op=='..'then b=b-1 end if b<v then g=false else g=true end elseif p.AstType=='UnopExpr'then k=w(k,p.Op)k=w(k,m(p.Rhs))elseif p.AstType=='DotsExpr'then k=k.."..."elseif p.AstType=='CallExpr'then k=k..m(p.Base)k=k.."("for q=1,#p.Arguments do k=k..m(p.Arguments[q])if q~=#p.Arguments then k=k..","end end k=k..")"elseif p.AstType=='TableCallExpr'then k=k..m(p.Base)k=k..m(p.Arguments[1])elseif p.AstType=='StringCallExpr'then k=k..m(p.Base)k=k..p.Arguments[1].Data elseif p.AstType=='IndexExpr'then k=k..m(p.Base).."["..m(p.Index).."]"elseif p.AstType=='MemberExpr'then k=k..m(p.Base)..p.Indexer..p.Ident.Data elseif p.AstType=='Function'then p.Scope:ObfuscateLocals()k=k.."function("if#p.Arguments>0 then for q=1,#p.Arguments do k=k..p.Arguments[q].Name if q~=#p.Arguments then k=k..","elseif p.VarArg then k=k..",..."end end elseif p.VarArg then k=k.."..."end k=k..")"k=w(k,c(p.Body))k=w(k,"end")elseif p.AstType=='ConstructorExpr'then k=k.."{"for q=1,#p.EntryList do local j=p.EntryList[q]if j.Type=='Key'then k=k.."["..m(j.Key).."]="..m(j.Value)elseif j.Type=='Value'then k=k..m(j.Value)elseif j.Type=='KeyString'then k=k..j.Key.."="..m(j.Value)end if q~=#p.EntryList then k=k..","end end k=k.."}"elseif p.AstType=='Parentheses'then k=k.."("..m(p.Inner)..")"end if not g then k=string.rep('(',p.ParenCount or 0)..k k=k..string.rep(')',p.ParenCount or 0)end return k end local y=function(p)local v=''if p.AstType=='AssignmentStatement'then for b=1,#p.Lhs do v=v..m(p.Lhs[b])if b~=#p.Lhs then v=v..","end end if#p.Rhs>0 then v=v.."="for b=1,#p.Rhs do v=v..m(p.Rhs[b])if b~=#p.Rhs then v=v..","end end end elseif p.AstType=='CallStatement'then v=m(p.Expression)elseif p.AstType=='LocalStatement'then v=v.."local "for b=1,#p.LocalList do v=v..p.LocalList[b].Name if b~=#p.LocalList then v=v..","end end if#p.InitList>0 then v=v.."="for b=1,#p.InitList do v=v..m(p.InitList[b])if b~=#p.InitList then v=v..","end end end elseif p.AstType=='IfStatement'then v=w("if",m(p.Clauses[1].Condition))v=w(v,"then")v=w(v,c(p.Clauses[1].Body))for b=2,#p.Clauses do local g=p.Clauses[b]if g.Condition then v=w(v,"elseif")v=w(v,m(g.Condition))v=w(v,"then")else v=w(v,"else")end v=w(v,c(g.Body))end v=w(v,"end")elseif p.AstType=='WhileStatement'then v=w("while",m(p.Condition))v=w(v,"do")v=w(v,c(p.Body))v=w(v,"end")elseif p.AstType=='DoStatement'then v=w(v,"do")v=w(v,c(p.Body))v=w(v,"end")elseif p.AstType=='ReturnStatement'then v="return"for b=1,#p.Arguments do v=w(v,m(p.Arguments[b]))if b~=#p.Arguments then v=v..","end end elseif p.AstType=='BreakStatement'then v="break"elseif p.AstType=='RepeatStatement'then v="repeat"v=w(v,c(p.Body))v=w(v,"until")v=w(v,m(p.Condition))elseif p.AstType=='Function'then p.Scope:ObfuscateLocals()if p.IsLocal then v="local"end v=w(v,"function ")if p.IsLocal then v=v..p.Name.Name else v=v..m(p.Name)end v=v.."("if#p.Arguments>0 then for b=1,#p.Arguments do v=v..p.Arguments[b].Name if b~=#p.Arguments then v=v..","elseif p.VarArg then v=v..",..."end end elseif p.VarArg then v=v.."..."end v=v..")"v=w(v,c(p.Body))v=w(v,"end")elseif p.AstType=='GenericForStatement'then p.Scope:ObfuscateLocals()v="for "for b=1,#p.VariableList do v=v..p.VariableList[b].Name if b~=#p.VariableList then v=v..","end end v=v.." in"for b=1,#p.Generators do v=w(v,m(p.Generators[b]))if b~=#p.Generators then v=w(v,',')end end v=w(v,"do")v=w(v,c(p.Body))v=w(v,"end")elseif p.AstType=='NumericForStatement'then p.Scope:ObfuscateLocals()v="for "v=v..p.Variable.Name.."="v=v..m(p.Start)..","..m(p.End)if p.Step then v=v..","..m(p.Step)end v=w(v,"do")v=w(v,c(p.Body))v=w(v,"end")elseif p.AstType=='LabelStatement'then v="::"..p.Label.."::"elseif p.AstType=='GotoStatement'then v="goto "..p.Label elseif p.AstType=='Comment'then elseif p.AstType=='Eof'then else error("Unknown AST Type: "..p.AstType)end return v end c=function(p)local v=''p.Scope:ObfuscateLocals()for b,g in pairs(p.Body)do v=w(v,y(g),';')end return v end return c(u)end local function d(u)local c=Parse.LexLua(u)c=Parse.ParseLua(c)return r(c)end local function l(u,c)c=c or u local m=io.open(u,"r")local f=m:read("*a")m:close()f=d(f)local w=io.open(c,"w")w:write(f)w:close()end return{JoinStatements=h,Minify=r,MinifyString=d,MinifyFile=l}end)return{Rebuild=Rebuild}end package.loaded["lib/minifier"]=nil do local t=package.preload["__luapack_entry__"](...)return t end